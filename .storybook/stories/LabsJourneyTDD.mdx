# Labs: Journey‑Driven TDD — Mocks First, Then MSW

import { Meta } from '@storybook/blocks';

<Meta title="Labs/Journey‑Driven TDD" />

Why
- Build features by walking a real user journey, driving it with tests and mocks.
- Start with pure UI and fake data; then plug in MSW contract; finally migrate to real services.

Recipe (RGR)
1) Red — write or adjust a failing story/test
   - Use play() in a journey demo or a component story to encode Given/When/Then
   - Example: QuizFlowDemo play() asserts 10 Q journey completes
2) Green — make the smallest change to pass
   - Use mock data first (EXPO_PUBLIC_USE_ALL_MOCKS=1)
   - Avoid wiring real clients; keep tests deterministic
3) Refactor — clean up while still green
   - Extract helpers; clarify names; remove dead code

MSW contract step
- Create a handler that matches the intended endpoint (e.g., POST /api/quiz/start)
- Update story play() to assert shape/status; add error branches (400/500)
- Once stable, keep MSW for Storybook, start real endpoint wiring guarded by env

Where to try it
- User journeys: ?path=/story/labs-user-journeys--page
- S2S orchestration: ?path=/story/labs-s2s-orchestration--page
- API Playground: ?path=/story/api-playground--default
- Quiz flow demo: ?path=/story/quizflowdemo--default

Tips
- Keep tests short and purposeful; assert behaviors not implementation
- Use global MSW profile toolbar (default/slower/flaky/chaos) to harden behaviors
- Record learnings in DevLog and link user journeys to epics

